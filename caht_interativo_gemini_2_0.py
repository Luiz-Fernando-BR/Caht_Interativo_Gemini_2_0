# -*- coding: utf-8 -*-
"""Caht_Interativo_Gemini_2_0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12X5GviFtpDpt0tDBOohPOMFW-8cw_qmi
"""

# @title Configure Gemini API key
# Importa a biblioteca do Google Generative AI para interagir com APIs generativas.
import google.generativeai as genai

# Importa o módulo de gerenciamento de segredos do Google Colab.
from google.colab import userdata

# Nome do segredo que contém a chave da API Gemini.
gemini_api_secret_name = 'GEMINI_API_KEY'  # @param {type: "string"}

try:
    # Obtém o valor do segredo armazenado no Google Colab usando o nome fornecido.
    GOOGLE_API_KEY = userdata.get(gemini_api_secret_name)

    # Configura a biblioteca genai para usar a chave da API obtida.
    genai.configure(api_key=GOOGLE_API_KEY)
except userdata.SecretNotFoundError as e:

    # Trata o erro caso o segredo não seja encontrado no Colab.
    print(f'Secret not found\n\nThis expects you to create a secret named {gemini_api_secret_name} in Colab\n\n'
          'Visit https://aistudio.google.com/app/apikey to create an API key\n\n'
          'Store that in the secrets section on the left side of the notebook (key icon)\n\n'
          f'Name the secret {gemini_api_secret_name}')
    raise e
except userdata.NotebookAccessError as e:
    # Trata o erro caso o acesso ao segredo no notebook não seja permitido.
    print(f'You need to grant this notebook access to the {gemini_api_secret_name} secret '
          'in order for the notebook to access Gemini on your behalf.')
    raise e
except Exception as e:
    # Trata quaisquer outros erros genéricos, sugerindo verificar o segredo e sua validade.
    print(f"There was an unknown error. Ensure you have a secret {gemini_api_secret_name} stored in Colab "
          "and it's a valid key from https://aistudio.google.com/app/apikey")
    raise e

"""# Parâmetros dos Modelos"""

# Importa a biblioteca `os` para interações com o sistema operacional (não usada no código, mas pode ser necessária para futuras funcionalidades).
import os
# Importa a biblioteca `google.generativeai` para interagir com modelos generativos da API Gemini.
import google.generativeai as genai

# Configuração do modelo de geração de texto.
generation_config = {
    "temperature": 1,  # Controla a aleatoriedade na geração de texto. Valores mais altos resultam em maior variação.
    "top_p": 0.95,  # Método de amostragem nucleus: considera somente as palavras no top 95% de probabilidade cumulativa.
    "top_k": 40,  # Limita a escolha às 40 palavras mais prováveis em cada passo.
    "max_output_tokens": 8192,  # Define o número máximo de tokens gerados na resposta.
    "response_mime_type": "text/plain",  # Define o formato do conteúdo da resposta gerada como texto simples.
}

# Cria um modelo generativo usando a configuração especificada.
model = genai.GenerativeModel(
    model_name="gemini-2.0-flash-exp",  # Nome do modelo a ser utilizado.
    generation_config=generation_config,  # Configurações de geração associadas ao modelo.
)

# Inicia uma sessão de chat com o modelo, permitindo manter um histórico de interações.
chat_session = model.start_chat(
    history=[  # Lista vazia: a sessão começa sem histórico de mensagens anteriores.
    ]
)

# Envia uma mensagem ao modelo na sessão de chat iniciada.
response = chat_session.send_message("INSERT_INPUT_HERE")  # Substitua "INSERT_INPUT_HERE" pelo texto de entrada desejado.

# Imprime o texto da resposta gerada pelo modelo.
print(response.text)

"""# Chat Iterativo"""

# Loop contínuo para interação com o usuário.
while True:
    # Solicita entrada do usuário para simular uma conversa.
    user_input = input("Você: ")  # Exibe "Você:" como prompt para o usuário digitar sua mensagem.

    # Verifica se o usuário deseja encerrar a conversa.
    if user_input.lower() in ["sair", "exit", "quit"]:  # Compara a entrada com palavras-chave para encerrar o programa.
        print("Encerrando o chat.")  # Mensagem de despedida antes de sair.
        break  # Encerra o loop.

    # Envia a mensagem do usuário para o modelo de chat configurado.
    response = chat_session.send_message(user_input)  # Obtém a resposta do modelo para a entrada do usuário.

    # Exibe a resposta gerada pelo modelo.
    print("Modelo:", response.text)  # Mostra a resposta com o prefixo "Modelo:".